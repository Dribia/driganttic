{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ganttic API client Documentation : https://dribia.github.io/driganttic/ Source Code : https://github.com/Dribia/driganttic API REST Ganttic client for python. Key features \ud83d\udd17 Client simple programmatic access to Ganttic API Rest Pydantic responses Warning Some relevant features are missing, because they were not relevant for our usecase. It only implements GET methods It does not implement all fields of Tasks, Resources and Projects as they were not needed to us It does not implement custom field fetchers for either texts or users Example \ud83d\udd17 The client is very trivial to use. It implement wrappers to the main types of available calls. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) All results are pydantic models already formatted with the interesting fields. See the fetcher.py file in /schemas for details. Modifications \ud83d\udd17 The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py class TaskDetails ( FetcherDetails ): \"\"\"Task List schema.\"\"\" # could be holidays projectId : Optional [ str ] resources : List [ str ] start : datetime . datetime end : datetime . datetime utilizationPercent : Optional [ float ] # Define here your custom fields my_custom_pydantic_name : Optional [ str ] Head to config/config.yaml and add your declared custom fields under the dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) custom_fields : tasks : listValues : my_custom_ganttic_name : my_pydnatic_name numbers : dates : projects : listValues : numbers : dates : resources : listValues : numbers : dates : Tip Make sure to pass as dictionaries the pairs ganttic names vs pydantic names in the appropriate order. License \ud83d\udd17 This software is licensed under the MIT license. MIT License Copyright (c) 2021 Dribia Data Research Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. TODOs \ud83d\udd17 Make optional to exhaust pages (now by default it exhausts the pages) Implement good testing, in line using TestClient from Starlette by mocking the API response. Implement modify, create and delete methods Implement custom data types texts and users","title":"driganttic"},{"location":"#key-features","text":"Client simple programmatic access to Ganttic API Rest Pydantic responses Warning Some relevant features are missing, because they were not relevant for our usecase. It only implements GET methods It does not implement all fields of Tasks, Resources and Projects as they were not needed to us It does not implement custom field fetchers for either texts or users","title":"Key features"},{"location":"#example","text":"The client is very trivial to use. It implement wrappers to the main types of available calls. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) All results are pydantic models already formatted with the interesting fields. See the fetcher.py file in /schemas for details.","title":"Example"},{"location":"#modifications","text":"The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py class TaskDetails ( FetcherDetails ): \"\"\"Task List schema.\"\"\" # could be holidays projectId : Optional [ str ] resources : List [ str ] start : datetime . datetime end : datetime . datetime utilizationPercent : Optional [ float ] # Define here your custom fields my_custom_pydantic_name : Optional [ str ] Head to config/config.yaml and add your declared custom fields under the dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) custom_fields : tasks : listValues : my_custom_ganttic_name : my_pydnatic_name numbers : dates : projects : listValues : numbers : dates : resources : listValues : numbers : dates : Tip Make sure to pass as dictionaries the pairs ganttic names vs pydantic names in the appropriate order.","title":"Modifications"},{"location":"#license","text":"This software is licensed under the MIT license. MIT License Copyright (c) 2021 Dribia Data Research Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"#todos","text":"Make optional to exhaust pages (now by default it exhausts the pages) Implement good testing, in line using TestClient from Starlette by mocking the API response. Implement modify, create and delete methods Implement custom data types texts and users","title":"TODOs"},{"location":"contribute/","text":"Contribute \ud83d\udd17 Contributions to Dribia libraries are always welcome! Mantainers \ud83d\udd17 driganttic is maintained by: Oleguer Sagarra Pascual - ula@dribia.com Source code \ud83d\udd17 In order to contribute, the first step is to clone yourself the code: repository : git clone git@github.com:Dribia/driganttic.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install pre-commit install Contribute \ud83d\udd17 Now you should be ready to start coding your contribution to the project. Just remember the following rules: Use Black for code linting and the PEP they respect. Branch the repo following an apropriate branching protocol . Always merge your contributions via pull requests, setting the maintainers as reviewers. When working on a release , follow the symver protocol . Happy coding!","title":"Contribute"},{"location":"contribute/#contribute","text":"Contributions to Dribia libraries are always welcome!","title":"Contribute"},{"location":"contribute/#mantainers","text":"driganttic is maintained by: Oleguer Sagarra Pascual - ula@dribia.com","title":"Mantainers"},{"location":"contribute/#source-code","text":"In order to contribute, the first step is to clone yourself the code: repository : git clone git@github.com:Dribia/driganttic.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install pre-commit install","title":"Source code"},{"location":"contribute/#contribute_1","text":"Now you should be ready to start coding your contribution to the project. Just remember the following rules: Use Black for code linting and the PEP they respect. Branch the repo following an apropriate branching protocol . Always merge your contributions via pull requests, setting the maintainers as reviewers. When working on a release , follow the symver protocol . Happy coding!","title":"Contribute"},{"location":"install/","text":"Poetry \ud83d\udd17 We recommend to use Poetry for dependency management. Add the dependency \ud83d\udd17 Once Poetry has been configured with the dripy repository you can add your driganttic dependency. At this moment, Poetry does not have a way to do this using only the CLI. You still have to configure the dripy source manually on your pyproject.toml file, by adding the following section: [[tool.poetry.source]] name = \"dripy\" url = \"https://dripy.dribia.dev\" secondary = true Now you can add driganttic as a dependency of your project as you would do with any other python package: poetry add driganttic","title":"Install"},{"location":"install/#poetry","text":"We recommend to use Poetry for dependency management.","title":"Poetry"},{"location":"install/#add-the-dependency","text":"Once Poetry has been configured with the dripy repository you can add your driganttic dependency. At this moment, Poetry does not have a way to do this using only the CLI. You still have to configure the dripy source manually on your pyproject.toml file, by adding the following section: [[tool.poetry.source]] name = \"dripy\" url = \"https://dripy.dribia.dev\" secondary = true Now you can add driganttic as a dependency of your project as you would do with any other python package: poetry add driganttic","title":"Add the dependency"},{"location":"usage/howto/","text":"Using the client \ud83d\udd17 The use is stragihtforward from this example, where all the functionality is shown. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) Tip Note that any of the get_tasks , get_projects , get_resources accept extra kwargs compatible with the Ganttic API GET methods. Things to note The client will automatically exhaust all the pagination if you use the get_something method (not the get_something_details ). The client returns pydantic models, where only the relevant data to our usecase has been kept. Warning The library has some limitations, mostly that the Error handling is not great for illformatted tasks Extending the client \ud83d\udd17 Say you want to extend the client to your needs. There are some simple steps to follow. The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py class TaskDetails ( FetcherDetails ): \"\"\"Task List schema.\"\"\" # could be holidays projectId : Optional [ str ] resources : List [ str ] start : datetime . datetime end : datetime . datetime utilizationPercent : Optional [ float ] # Define here your custom fields my_custom_pydantic_name : Optional [ str ] Head to config/config.yaml and add your declared custom fields under the dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) custom_fields : tasks : listValues : my_custom_ganttic_name : my_pydnatic_name numbers : dates : projects : listValues : numbers : dates : resources : listValues : numbers : dates : Warning Custom text and user fields are currently not supported.","title":"Using the client"},{"location":"usage/howto/#using-the-client","text":"The use is stragihtforward from this example, where all the functionality is shown. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) Tip Note that any of the get_tasks , get_projects , get_resources accept extra kwargs compatible with the Ganttic API GET methods. Things to note The client will automatically exhaust all the pagination if you use the get_something method (not the get_something_details ). The client returns pydantic models, where only the relevant data to our usecase has been kept. Warning The library has some limitations, mostly that the Error handling is not great for illformatted tasks","title":"Using the client"},{"location":"usage/howto/#extending-the-client","text":"Say you want to extend the client to your needs. There are some simple steps to follow. The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py class TaskDetails ( FetcherDetails ): \"\"\"Task List schema.\"\"\" # could be holidays projectId : Optional [ str ] resources : List [ str ] start : datetime . datetime end : datetime . datetime utilizationPercent : Optional [ float ] # Define here your custom fields my_custom_pydantic_name : Optional [ str ] Head to config/config.yaml and add your declared custom fields under the dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) custom_fields : tasks : listValues : my_custom_ganttic_name : my_pydnatic_name numbers : dates : projects : listValues : numbers : dates : resources : listValues : numbers : dates : Warning Custom text and user fields are currently not supported.","title":"Extending the client"}]}
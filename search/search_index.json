{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ganttic API client Documentation : https://dribia.github.io/driganttic/ Source Code : https://github.com/Dribia/driganttic API REST Ganttic client for python. Key features \ud83d\udd17 Client simple programmatic access to Ganttic API Rest Pydantic responses Warning Some relevant features are missing, because they were not relevant for our usecase. * It only implements GET methods * It does not implement all fields of Tasks, Resources and Projects as they were not needed to us * It does not implement custom field fetchers for either texts or users Example \ud83d\udd17 The client is very trivial to use. It implement wrappers to the main types of available calls. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) All results are pydantic models already formatted with the interesting fields. See the fetcher.py file in /schemas for details. Modifications \ud83d\udd17 The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py Head to parse.py and add your declared custom fields under the CUSTOM_FIELDS dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) CUSTOM_FIELDS = { 'task' : { # define pairs of name in the dict, one for the pydantic and one for the ganttic name 'listValues' : { 'my_custom_pydantic_name_field' : \u00a1 'my_custom_ganttic_field_name' }, 'numbers' : {}, 'dates' : {}, }, 'resource' : { 'listValues' : {}, 'numbers' : {}, 'dates' : {}, }, 'project' : { 'listValues' : {}, 'numbers' : {}, 'dates' : {}, }, } Tip Make sure to pass as dictionaries the pairs ganttic names vs pydantic names in the apropriate order. TODOs \ud83d\udd17 Better docs on limitations (pagination, custom fields, not implemented fields) Move all custom related field definition to configuration yaml file Make optional to exhaust pages (now by default it exhausts the pages) Implement good testing, in line using TestClient from Starlette by mocking the API response. Implement modify, create and delete methods Implement custom data types texts and users","title":"driganttic"},{"location":"#key-features","text":"Client simple programmatic access to Ganttic API Rest Pydantic responses Warning Some relevant features are missing, because they were not relevant for our usecase. * It only implements GET methods * It does not implement all fields of Tasks, Resources and Projects as they were not needed to us * It does not implement custom field fetchers for either texts or users","title":"Key features"},{"location":"#example","text":"The client is very trivial to use. It implement wrappers to the main types of available calls. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) All results are pydantic models already formatted with the interesting fields. See the fetcher.py file in /schemas for details.","title":"Example"},{"location":"#modifications","text":"The only changes needed here are to adapt to your own custom data fields. To do so, you need to do two things: Define the relevant fields in the pydantic model definition in schemas/fetcher.py Head to parse.py and add your declared custom fields under the CUSTOM_FIELDS dict for the relevant fetcher (task, project or resource) and type (number, date, listvalue, user or text) CUSTOM_FIELDS = { 'task' : { # define pairs of name in the dict, one for the pydantic and one for the ganttic name 'listValues' : { 'my_custom_pydantic_name_field' : \u00a1 'my_custom_ganttic_field_name' }, 'numbers' : {}, 'dates' : {}, }, 'resource' : { 'listValues' : {}, 'numbers' : {}, 'dates' : {}, }, 'project' : { 'listValues' : {}, 'numbers' : {}, 'dates' : {}, }, } Tip Make sure to pass as dictionaries the pairs ganttic names vs pydantic names in the apropriate order.","title":"Modifications"},{"location":"#todos","text":"Better docs on limitations (pagination, custom fields, not implemented fields) Move all custom related field definition to configuration yaml file Make optional to exhaust pages (now by default it exhausts the pages) Implement good testing, in line using TestClient from Starlette by mocking the API response. Implement modify, create and delete methods Implement custom data types texts and users","title":"TODOs"},{"location":"contribute/","text":"Contribute \ud83d\udd17 Contributions to Dribia libraries are always welcome! Mantainers \ud83d\udd17 driganttic is maintained by: Oleguer Sagarra Pascual - ula@dribia.com Source code \ud83d\udd17 In order to contribute, the first step is to clone yourself the code: repository : git clone git@github.com:Dribia/driganttic.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install pre-commit install Contribute \ud83d\udd17 Now you should be ready to start coding your contribution to the project. Just remember the following rules: Use Black for code linting and the PEP they respect. Branch the repo following an apropriate branching protocol . Always merge your contributions via pull requests, setting the maintainers as reviewers. When working on a release , follow the symver protocol . Happy coding!","title":"Contribute"},{"location":"contribute/#contribute","text":"Contributions to Dribia libraries are always welcome!","title":"Contribute"},{"location":"contribute/#mantainers","text":"driganttic is maintained by: Oleguer Sagarra Pascual - ula@dribia.com","title":"Mantainers"},{"location":"contribute/#source-code","text":"In order to contribute, the first step is to clone yourself the code: repository : git clone git@github.com:Dribia/driganttic.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install pre-commit install","title":"Source code"},{"location":"contribute/#contribute_1","text":"Now you should be ready to start coding your contribution to the project. Just remember the following rules: Use Black for code linting and the PEP they respect. Branch the repo following an apropriate branching protocol . Always merge your contributions via pull requests, setting the maintainers as reviewers. When working on a release , follow the symver protocol . Happy coding!","title":"Contribute"},{"location":"install/","text":"Poetry \ud83d\udd17 We recommend to use Poetry for dependency management. Add the dependency \ud83d\udd17 Once Poetry has been configured with the dripy repository you can add your driganttic dependency. At this moment, Poetry does not have a way to do this using only the CLI. You still have to configure the dripy source manually on your pyproject.toml file, by adding the following section: [[tool.poetry.source]] name = \"dripy\" url = \"https://dripy.dribia.dev\" secondary = true Now you can add driganttic as a dependency of your project as you would do with any other python package: poetry add driganttic","title":"Install"},{"location":"install/#poetry","text":"We recommend to use Poetry for dependency management.","title":"Poetry"},{"location":"install/#add-the-dependency","text":"Once Poetry has been configured with the dripy repository you can add your driganttic dependency. At this moment, Poetry does not have a way to do this using only the CLI. You still have to configure the dripy source manually on your pyproject.toml file, by adding the following section: [[tool.poetry.source]] name = \"dripy\" url = \"https://dripy.dribia.dev\" secondary = true Now you can add driganttic as a dependency of your project as you would do with any other python package: poetry add driganttic","title":"Add the dependency"},{"location":"usage/howto/","text":"Using the client \ud83d\udd17 The use is stragihtforward from this example, where all the functionality is shown. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) Tip Note that any of the get_tasks , get_projects , get_resources accept extra kwargs compatible with the Ganttic API GET methods. Things to note The client will automatically exhaust all the pagination if you use the get_something method (not the get_something_details ). The client returns pydantic models, where only the relevant data to our usecase has been kept. Warning The library has some limitations, mostly that the Error handling is not great for illformatted tasks Extending the client \ud83d\udd17 Say you want to extend the client to your needs. There are some simple steps to follow. Head to /driganttic/fetcher.py and edit the relevant pydantic models to your needs. You can add there data validation, data types and optional types. Head to /driganttic/parse.py and edit the CUSTOM_FIELDS dictionary with your speciffic custom data types. Head to /driganttic/tests/ and add the relevant tests for the defined data fields. Tip Make sure to use the auxiliary functions parse_timestamp and get_Y (with Y being category, number or date) to handle the custom defined datafields. Warning Custom text and userfields are currently not supported.","title":"Using the client"},{"location":"usage/howto/#using-the-client","text":"The use is stragihtforward from this example, where all the functionality is shown. from driganttic import parse as dg_parse from driganttic import client as dg_client APIKEY = 'yourapikey' Client = dg_client . GantticClient ( APIKEY = APIKEY ) # get dictionary of custom fields dict_of_fields = Client . Translator print ( f 'Available fetchers: { dg_client . FETCHERS } ' ) # get all projects, tasks and resources projects = Client . get_projects () tasks = Client . get_tasks ( timeMin = dg_parse . parse_timestamp ( '2021-01-01' ), timeMax = dg_parse . parse_timestamp ( '2021-04-30' )) resources = Client . get_resources () p_id = projects . fetched_items . pop () . id t_id = tasks . fetched_items . pop () . id r_id = resources . fetched_items . pop () . id one_project = Client . get_project_details ( projectId = p_id ) one_task = Client . get_task_details ( taskId = t_id ) one_resource = Client . get_resource_details ( resourceId = r_id ) Tip Note that any of the get_tasks , get_projects , get_resources accept extra kwargs compatible with the Ganttic API GET methods. Things to note The client will automatically exhaust all the pagination if you use the get_something method (not the get_something_details ). The client returns pydantic models, where only the relevant data to our usecase has been kept. Warning The library has some limitations, mostly that the Error handling is not great for illformatted tasks","title":"Using the client"},{"location":"usage/howto/#extending-the-client","text":"Say you want to extend the client to your needs. There are some simple steps to follow. Head to /driganttic/fetcher.py and edit the relevant pydantic models to your needs. You can add there data validation, data types and optional types. Head to /driganttic/parse.py and edit the CUSTOM_FIELDS dictionary with your speciffic custom data types. Head to /driganttic/tests/ and add the relevant tests for the defined data fields. Tip Make sure to use the auxiliary functions parse_timestamp and get_Y (with Y being category, number or date) to handle the custom defined datafields. Warning Custom text and userfields are currently not supported.","title":"Extending the client"}]}